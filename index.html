<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>千熊的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="千熊的博客">
<meta property="og:url" content="http://windinpub.com/index.html">
<meta property="og:site_name" content="千熊的博客">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="千熊的博客">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://windinpub.com"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">千熊的博客</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Flutter状态管理学习手册[三]——Bloc" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/02/Flutter状态管理学习手册[三]——Bloc/" class="article-date">
  <time datetime="2019-05-02T08:06:46.000Z" itemprop="datePublished">2019-05-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/02/Flutter状态管理学习手册[三]——Bloc/">Flutter状态管理学习手册[三]——Bloc</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h3 id="一、Bloc-介绍"><a href="#一、Bloc-介绍" class="headerlink" title="一、Bloc 介绍"></a>一、Bloc 介绍</h3><p>Bloc 的名字比较新颖，这个状态管理框架的目的是将 UI 层和业务逻辑进行分离。Bloc 的复杂度处于 ScopedModel 和 Redux 之间，相较于 ScopedModel，Bloc 拥有分明的架构处于业务逻辑，相较于 Redux，Bloc 着重于业务逻辑的分解，使得整个框架对于开发来讲简单实用。</p>
<h3 id="二、Bloc-的层次结构"><a href="#二、Bloc-的层次结构" class="headerlink" title="二、Bloc 的层次结构"></a>二、Bloc 的层次结构</h3><p>Bloc 分为三层：</p>
<ul>
<li>Data Layer(数据层)，用于提供数据。</li>
<li>Bloc(Business Logic) Layer(业务层)，通过继续 Bloc 类实现，用于处理业务逻辑。</li>
<li>Presentation Layer(表现层)，用于 UI 构建。</li>
</ul>
<p>Presentation Layer 只与 Bloc Layer 交互，Data Laye 也只与 Bloc Layer 交互。Bloc Layer 作为重要一层，处于表现层和数据层之间，使得 UI 和数据通过 Bloc Layer 进行交互。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/4/169e7920036aa4a9?w=1589&amp;h=292&amp;f=png&amp;s=59753" alt></p>
<p>由此可见，Bloc 的架构和客户端主流的 MVC 和 MVP 架构比较相似，但也存在 Event 和 State 的概念一同构成响应式框架。</p>
<h3 id="三、Bloc-需要知道的概念"><a href="#三、Bloc-需要知道的概念" class="headerlink" title="三、Bloc 需要知道的概念"></a>三、Bloc 需要知道的概念</h3><p>BlocProvider，通常做为 App 的根布局。BlocProvider 可以保存 Bloc，在其它页面通过<code>BlocProvider.of&lt;Bloc&gt;(context)</code>获取 Bloc。</p>
<p>Event，用户操作 UI 后发出的事件，用于通知 Bloc 层事件发生。</p>
<p>State，页面状态，可用于构建 UI。通常是 Bloc 将接收到的 Event 转化为 State。</p>
<p>Bloc 架构的核心是 Bloc 类，Bloc 类是一个抽象类，有一个 <code>mapEventToState（event）</code>方法需要实现。<code>mapEventToState（event）</code>顾名思义，就是将用户点击 View 时发出的 event 转化为构建 UI 所用的 State。另外，在 StatefulWidget 中使用 bloc 的话，在 widget dispose 时，要调用 <code>bloc.dispose()</code>方法进行释放。</p>
<h3 id="四、Bloc-的实践"><a href="#四、Bloc-的实践" class="headerlink" title="四、Bloc 的实践"></a>四、Bloc 的实践</h3><p>这里以常见的获取列表选择列表为例子。一个页面用于展示选中项和跳转到列表，一个页面用于显示列表。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/15/16a1f88c7228f97b?w=422&amp;h=768&amp;f=gif&amp;s=871567" alt></p>
<ol>
<li>引入 Redux 的第三方库</li>
</ol>
<p>在 <code>pubspec.yaml</code> 文件中引入 <code>flutter_bloc</code> 第三方库支持 bloc 功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 引入 bloc 第三方库</span><br><span class="line">flutter_bloc: ^0.9.0</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用 Bloc 插件</li>
</ol>
<p>这一步可有可无，但使用插件会方便开发，不使用的话也没什么问题。</p>
<p>Bloc 官方提供了 VSCode 和 Android studio 的插件，方便生成 Bloc 框架用到的相关类。<br>下文以 Android studio 的插件为例。</p>
<p>比如 list 页面，该插件会生成相应的类</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/15/16a1f988412eb98d?w=202&amp;h=130&amp;f=png&amp;s=2565" alt></p>
<p>从生成的五个文件中也可以看到，<code>list_bloc</code> 负责承载业务逻辑，<code>list_page</code> 负责编写 UI 界面，<code>list_event</code> 和 <code>list_state</code> 分别是事件和状态，其中 <code>list.dart</code> 文件是用于导出前面四个文件的。</p>
<p>具体使用可见</p>
<p><a href="https://felangel.github.io/bloc/#/blocintellijextension" target="_blank" rel="noopener">Android studio 的 Bloc 插件</a></p>
<p><a href="https://felangel.github.io/bloc/#/blocvscodeextension" target="_blank" rel="noopener">VSCode 的 Bloc 插件</a></p>
<ol start="3">
<li>使用 BlocProvider 作为根布局</li>
</ol>
<p>在 <code>main.dart</code> 中，使用 BlocProvider 作为父布局包裹，用于传递需要的 bloc。Demo 中包含两个页面，一个是展示页面 ShowPage，一个是列表页面 ListPage。</p>
<p>上面讲到，Bloc 的核心功能在于 Bloc 类，对于展示页面 ShowPage，会有一个 ShowBloc 继续自 Bloc 类。由于展示页面 ShowPage 会和列表页面 ListPage 有数据的互动，所以这里将 ShowBloc 保存在 BlocProvider 中进行传递。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return BlocProvider(</span><br><span class="line">        bloc: _showBloc,</span><br><span class="line">        child: MaterialApp(</span><br><span class="line">            title: &apos;Flutter Demo&apos;,</span><br><span class="line">            theme: ThemeData(</span><br><span class="line">              primarySwatch: Colors.blue,</span><br><span class="line">            ),</span><br><span class="line">            home: ShowPage()));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>展示页面 ShowPage</li>
</ol>
<p>① ShowEvent</p>
<p>列表的 item 点击后，需要发送一个 event 通知其它页面列表被选中，这里定义一个 SelectShowEvent 作为这种 event 通知。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class SelectShowEvent extends ShowEvent &#123;</span><br><span class="line">  String selected;</span><br><span class="line"></span><br><span class="line">  SelectShowEvent(this.selected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>② ShowState</p>
<p>State 用于表示一种界面状态，即一个 State 就对应一个界面。插件在一开始会生成一个默认状态，InitialShowState。我们可以使用 InitialShowState 来代表初始的界面。另外，我们自己定义一种状态，SelectedShowState，代表选中列表后的 State。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@immutable</span><br><span class="line">abstract class ShowState &#123;&#125;</span><br><span class="line"></span><br><span class="line">class InitialShowState extends ShowState &#123;&#125;</span><br><span class="line"></span><br><span class="line">class SelectedShowState extends ShowState &#123;</span><br><span class="line">  String _selectedString = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">  String get selected =&gt; _selectedString;</span><br><span class="line"></span><br><span class="line">  SelectedShowState(this._selectedString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>③ ShowBloc</p>
<p>Bloc 的主要职责是接收 Event，然后把 Event 转化为对应的 State。这里的 ShowBloc 继续自 Bloc，需要重写实现抽象方法 <code>mapEventToState(event)</code>。在这个方法中，我们判断传过来的 event 是不是 SelectShowEvent，是则拿到 SelectShowEvent 中的 selected 变量去构建 SelectedShowState。<code>mapEventToState(event)</code>返回的是一个 Stream，我们通过 yield 关键字去返回一个 SelectedShowState。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class ShowBloc extends Bloc&lt;ShowEvent, ShowState&gt; &#123;</span><br><span class="line">  @override</span><br><span class="line">  ShowState get initialState =&gt; InitialShowState();</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Stream&lt;ShowState&gt; mapEventToState(</span><br><span class="line">    ShowEvent event,</span><br><span class="line">  ) async* &#123;</span><br><span class="line">    if (event is SelectShowEvent) &#123;</span><br><span class="line">      yield SelectedShowState(event.selected);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>④ ShowPage</p>
<p>在 ShowPage 的界面上，我们需要根据 showBloc 中是否有被选中的列表项目去展于页面，所以这里我们先使用使用<code>BlocProvider.of&lt;ShowBloc&gt;(context)</code>去拿到 showBloc，接着再用 BlocBuilder 根据 showBloc 构建界面。使用 BlocBuilder 的好处就是可以让页面自动响应 showBloc 的变化而变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var showBloc = BlocProvider.of&lt;ShowBloc&gt;(context);</span><br><span class="line">...</span><br><span class="line">BlocBuilder(</span><br><span class="line">    bloc: showBloc,</span><br><span class="line">    builder: (context, state) &#123;</span><br><span class="line">      if (state is SelectedShowState) &#123;</span><br><span class="line">        return Text(state.selected);</span><br><span class="line">      &#125;</span><br><span class="line">      return Text(&quot;&quot;);</span><br><span class="line">    &#125;),</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>列表页面 ListPage</li>
</ol>
<p>① ListEvent</p>
<p>列表页面，我们一开始需要从网络中拉取列表数据，所以定义一个 FetchListEvent 事件在进入页面时通知 ListBloc 去获取列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@immutable</span><br><span class="line">abstract class ListEvent extends Equatable &#123;</span><br><span class="line">  ListEvent([List props = const []]) : super(props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class FetchListEvent extends ListEvent &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>② ListState</p>
<p>InitialListState 是插件默认生成的初始状态，另外定义一个 FetchListState 代表获取列表完成的状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@immutable</span><br><span class="line">abstract class ListState extends Equatable &#123;</span><br><span class="line">  ListState([List props = const []]) : super(props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class InitialListState extends ListState &#123;&#125;</span><br><span class="line"></span><br><span class="line">class FetchListState extends ListState &#123;</span><br><span class="line"></span><br><span class="line">  List&lt;String&gt; _list = [];</span><br><span class="line"></span><br><span class="line">  UnmodifiableListView&lt;String&gt; get list =&gt; UnmodifiableListView(_list);</span><br><span class="line"></span><br><span class="line">  FetchListState(this._list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>③ ListBloc</p>
<p>在 ListBloc 中，进行从网络获取列表数据的业务。这里通过一个延时操作摸拟网络请求，最后用 yield 返回列表数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class ListBloc extends Bloc&lt;ListEvent, ListState&gt; &#123;</span><br><span class="line">  @override</span><br><span class="line">  ListState get initialState =&gt; InitialListState();</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Stream&lt;ListState&gt; mapEventToState(</span><br><span class="line">    ListEvent event,</span><br><span class="line">  ) async* &#123;</span><br><span class="line">    if (event is FetchListEvent) &#123;</span><br><span class="line">      // 模拟网络请求</span><br><span class="line">      await Future.delayed(Duration(milliseconds: 2000));</span><br><span class="line">      var list = [</span><br><span class="line">        &quot;1. Bloc artitechture&quot;,</span><br><span class="line">        &quot;2. Bloc artitechture&quot;,</span><br><span class="line">        &quot;3. Bloc artitechture&quot;,</span><br><span class="line">        &quot;4. Bloc artitechture&quot;,</span><br><span class="line">        &quot;5. Bloc artitechture&quot;,</span><br><span class="line">        &quot;6. Bloc artitechture&quot;,</span><br><span class="line">        &quot;7. Bloc artitechture&quot;,</span><br><span class="line">        &quot;8. Bloc artitechture&quot;,</span><br><span class="line">        &quot;9. Bloc artitechture&quot;,</span><br><span class="line">        &quot;10. Bloc artitechture&quot;</span><br><span class="line">      ];</span><br><span class="line"></span><br><span class="line">      yield FetchListState(list);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>④ ListPage</p>
<p>在列表页面初始化时有两个操作，一个是初始化 listBloc，一个是发出列表请求的 Event。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">void initState() &#123;</span><br><span class="line">  bloc = ListBloc(); // 初始化listBloc</span><br><span class="line">  bloc.dispatch(FetchListEvent()); // 发出列表请求事件</span><br><span class="line">  super.initState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下用，便是用 BlocBuilder 去响应状态。当 state 是 InitialListState，说明未获取列表，则显示 loading 界面，当 state 是 FetchListState 时，说明已经成功获取列表，显示列表界面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">body: BlocBuilder(</span><br><span class="line">    bloc: bloc,</span><br><span class="line">    builder: (context, state) &#123;</span><br><span class="line">      // 根据状态显示界面</span><br><span class="line">      if (state is InitialListState) &#123;</span><br><span class="line">        // 显示 loading 界面</span><br><span class="line">        return buildLoad();</span><br><span class="line">      &#125; else if (state is FetchListState) &#123;</span><br><span class="line">        // 显示列表界面</span><br><span class="line">        var list = state.list;</span><br><span class="line">        return buildList(list);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;));</span><br></pre></td></tr></table></figure>
<p>最后，记得对 bloc 进行 <code>dispose()</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">void dispose() &#123;</span><br><span class="line">  bloc.dispose();</span><br><span class="line">  super.dispose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体代码可以到<a href="https://github.com/windinwork/bloc_app" target="_blank" rel="noopener"> github </a>查看。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在 Bloc 的架构中，将一个页面和一个 Bloc 相结合，由页面产生 Event，Bloc 根据业务需要将 Event 转化为 State，再把 State 交给页面中的 BlocBuilder 构建 UI。Demo 中只是给出了简单的状态管理，实际项目中，比如网络请求，有请求中、请求成功、请求失败的多种状态，可以做适当封装使 Bloc 更加易用。相比于 Redux，Bloc 不需要将所有状态集中管理，这样对于不同模块的页面易于拆分，对于代码量比较大的客户端而言，Bloc 的架构会相对比较友好。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://windinpub.com/2019/05/02/Flutter状态管理学习手册[三]——Bloc/" data-id="cjv6d9l920000ebi7vbtwtgw9" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-Flutter状态管理学习手册[二]——Redux" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/04/Flutter状态管理学习手册[二]——Redux/" class="article-date">
  <time datetime="2019-04-04T10:00:56.000Z" itemprop="datePublished">2019-04-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/04/Flutter状态管理学习手册[二]——Redux/">Flutter状态管理学习手册[二]——Redux</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>上一篇讲到了一个简单的状态管理架构—— <a href="https://juejin.im/post/5ca2c0266fb9a05e345bcdd4" target="_blank" rel="noopener">ScopedModel</a> , 当然，这种简单的架构会用在商业项目中的概率比较小，本篇则讲述另一个架构： Redux ，一个优雅且实用的状态管理框架。本篇 Demo 地址：<a href="https://github.com/windinwork/flutter_redux_app" target="_blank" rel="noopener">https://github.com/windinwork/flutter_redux_app</a></p>
</blockquote>
<h3 id="一、Redux-的准备工作"><a href="#一、Redux-的准备工作" class="headerlink" title="一、Redux 的准备工作"></a>一、Redux 的准备工作</h3><p>Redux 的概念源于 React，对于不是从事前端工作或者没有接触过 React 的人要理解 Redux 会比较繁复。对于不了解 Redux 的小伙伴，这里有两篇很不错的文章介绍了 Redux 的概念和相关知识：</p>
<p><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html" target="_blank" rel="noopener">Redux 入门教程（一）：基本用法</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html" target="_blank" rel="noopener">Redux 入门教程（二）：中间件与异步操作</a></p>
<h3 id="二、Redux的概念"><a href="#二、Redux的概念" class="headerlink" title="二、Redux的概念"></a>二、Redux的概念</h3><p>学习后 Redux 可以了解到，Redux 主要由涉及下面几种概念：</p>
        
          <p class="article-more-link">
            <a href="/2019/04/04/Flutter状态管理学习手册[二]——Redux/#more">继续阅读全文 »</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://windinpub.com/2019/04/04/Flutter状态管理学习手册[二]——Redux/" data-id="cjv6d9l9i0004ebi7fp150fe7" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-Flutter状态管理学习手册[一]——ScopedModel" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/02/Flutter状态管理学习手册[一]——ScopedModel/" class="article-date">
  <time datetime="2019-04-02T10:00:36.000Z" itemprop="datePublished">2019-04-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/02/Flutter状态管理学习手册[一]——ScopedModel/">Flutter状态管理学习手册[一]——ScopedModel</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一、ScopedModel简介"><a href="#一、ScopedModel简介" class="headerlink" title="一、ScopedModel简介"></a>一、ScopedModel简介</h3><p><code>ScopedModel</code>属于入门级别的状态管理框架，它的思想比较简单，参考官方文档便可以很容易理解其中构架。</p>
<p>在<code>Flutter</code>中<code>Lifting state up</code>(状态提升)是十分必要的，状态提升可以理解为把组件之间相互共享的状态提取出来放在一个较高层级中管理的一种思想。<code>ScopedModel</code>提供了对于这种状态管理的便利。</p>
<h3 id="二、ScopedModel中的三个概念"><a href="#二、ScopedModel中的三个概念" class="headerlink" title="二、ScopedModel中的三个概念"></a>二、ScopedModel中的三个概念</h3><p><code>ScopedModel</code>主要有三个重要的概念，也是其中的三个类：<code>Model</code>、<code>ScopedModel</code>和<code>ScopedModelDescendant</code>。<code>ScopedModel</code>基本上通过这三个类实现其功能。</p>
        
          <p class="article-more-link">
            <a href="/2019/04/02/Flutter状态管理学习手册[一]——ScopedModel/#more">继续阅读全文 »</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://windinpub.com/2019/04/02/Flutter状态管理学习手册[一]——ScopedModel/" data-id="cjv6d9l980001ebi7s2h6vqwd" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-Android应用集成Office文件能力完全攻略" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/28/Android应用集成Office文件能力完全攻略/" class="article-date">
  <time datetime="2019-01-28T09:58:46.000Z" itemprop="datePublished">2019-01-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/28/Android应用集成Office文件能力完全攻略/">Android应用集成Office文件能力完全攻略</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>不同于iOS，Android的webView不支持打开office和pdf文档，所以当我们遇到在应用内打开office和pdf文档的需求时，往往无法从系统原生功能去支持。这篇文章的写下笔者在Android应用中集成office和pdf文件能力的心得，附上demo地址：<a href="https://github.com/windinwork/OfficeApplication" target="_blank" rel="noopener">https://github.com/windinwork/OfficeApplication</a></p>
</blockquote>
<h3 id="一、确定解决方案"><a href="#一、确定解决方案" class="headerlink" title="一、确定解决方案"></a>一、确定解决方案</h3><p>Android应用打开office和pdf文件。常用的有以下四种解决方案：</p>
<ol>
<li>在线网页打开文件方案：通过微软或谷歌提供的在线页面打开office和pdf文件</li>
<li>集成相关文档处理开源库：通过集成开源库类似于AndroidPdfViewer</li>
<li>通过系统中的第三方应用打开文档</li>
<li>集成腾讯x5 sdk文件能力</li>
</ol>
<p>四种方案各有优劣，这里笔者选择了x5 sdk为主要手段，第三方应用辅助的这样一种解决方案</p>
<h3 id="二、集成x5内核"><a href="#二、集成x5内核" class="headerlink" title="二、集成x5内核"></a>二、集成x5内核</h3><p>腾讯官方提供的x5内核有两个版本，这里选择具有文件能和的sdk：</p>
        
          <p class="article-more-link">
            <a href="/2019/01/28/Android应用集成Office文件能力完全攻略/#more">继续阅读全文 »</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://windinpub.com/2019/01/28/Android应用集成Office文件能力完全攻略/" data-id="cjv6d9l9e0002ebi7whg8jl9d" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-使用Gradle编写蒲公英自动上传安装包和更新说明脚本" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/02/使用Gradle编写蒲公英自动上传安装包和更新说明脚本/" class="article-date">
  <time datetime="2018-12-02T09:58:40.000Z" itemprop="datePublished">2018-12-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/02/使用Gradle编写蒲公英自动上传安装包和更新说明脚本/">使用Gradle编写蒲公英自动上传安装包和更新说明脚本</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Github: <a href="https://github.com/windinwork/PgyerGradleApplication" target="_blank" rel="noopener">https://github.com/windinwork/PgyerGradleApplication</a></p>
</blockquote>
<p>平时测试中发包的时候，笔者在打完包就直接拖到蒲公英上让它上传就完事了。不过前两天的会议上，测试小姐姐提出要在蒲公英上写明这次的测试包修改了什么内容。</p>
<p>笔者一想到上传完包还要一个个打字说明在这个包我修改了什么，立即强烈拒绝！但是测试小姐姐再三要求，碍于这确实是个好提议和会上坐着的老大，只好勉为其难地答应发包时写上改动内容T_T。但是懒惰如笔者，当然不会每次发包都手动打字啦，最好能打完包后自动把包和修改信息上传到蒲公英。</p>
<p>虽然嘴上说着不要不要，但笔者想到写个自动化脚本还是很兴奋的。本来想看看有没有现成的蒲公英自动上传脚本，在网上搜索了一下发现都不是很对胃口，想想还是自己写算了。所以今天花了半天写了这个脚本，在这里也分享一下相关的gradle配置，以供参考。</p>
        
          <p class="article-more-link">
            <a href="/2018/12/02/使用Gradle编写蒲公英自动上传安装包和更新说明脚本/#more">继续阅读全文 »</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://windinpub.com/2018/12/02/使用Gradle编写蒲公英自动上传安装包和更新说明脚本/" data-id="cjv6d9l9g0003ebi7msnkfxka" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-美团多渠道打包工具Walle源码解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/12/美团多渠道打包工具Walle源码解析/" class="article-date">
  <time datetime="2018-11-12T09:58:19.000Z" itemprop="datePublished">2018-11-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/12/美团多渠道打包工具Walle源码解析/">美团多渠道打包工具Walle源码解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>笔者现在在负责一个新的<code>Android</code>项目，前期功能不太复杂，安装包的体积小，渠道要求也较少，所以打渠道包使用<code>Android Studio</code>自带的打包方法。原生方法打渠道包大约八分钟左右就搞定了，顺便可以悠闲地享受一下这种打包方式的乐趣。但是，随着重的功能的加入和渠道的增加，原生方法打渠道包就显得有点慢了，所以集成了美团的多渠道打包工具<code>Walle</code>，顺便看了一下里面的实现原理。</p>
</blockquote>
<h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>这一次的原理分析仅仅针对<code>Android Signature V2 Scheme</code>。</p>
<p>在上一家公司的时候，笔者所在的<code>Android</code>团队经历了<code>Android Signature V1</code>到<code>Android Signature V2</code>的变更，其中因为未及时从<code>V1</code>升级到<code>V2</code>而导致上线受阻，当时也紧急更换了新的多渠道打包工具来解决问题。在我自己使用多渠道打包工具时，不免对<code>V2</code>签名验证的方式有了一丝好奇，想去看看<code>V2</code>签名验证和多渠道打包的实现原理。</p>
        
          <p class="article-more-link">
            <a href="/2018/11/12/美团多渠道打包工具Walle源码解析/#more">继续阅读全文 »</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://windinpub.com/2018/11/12/美团多渠道打包工具Walle源码解析/" data-id="cjv6d9lac0006ebi79j0lhoe5" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-通过字节码看原理，带你去找kotlin中的static方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/04/通过字节码看原理，带你去找kotlin中的static方法/" class="article-date">
  <time datetime="2018-11-04T09:58:07.000Z" itemprop="datePublished">2018-11-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/04/通过字节码看原理，带你去找kotlin中的static方法/">通过字节码看原理，带你去找kotlin中的static方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p><code>kotlin</code>在被钦定为<code>Android</code>的官方开发语言后，越来越多的<code>Android</code>开发者投向<code>kotlin</code>的怀抱。尽管<code>kotlin</code>兼容<code>Java</code>，但在使用上还是有很大不同的，就像<code>static</code>关键字，我们可以用<code>companion object</code>来替代<code>static</code>，当我们用反射去调用时，会发现调用时并不像<code>static</code>那样直接，笔者在日常使用中就遇到这样的问题，想拿反射去调用静态方法时无法调用，所以便通过字节码的实现来一窥究竟，顺便水一篇文章（●&gt;∀&lt;●）。</p>
</blockquote>
<h3 id="一、如何查看kotlin字节码"><a href="#一、如何查看kotlin字节码" class="headerlink" title="一、如何查看kotlin字节码"></a>一、如何查看kotlin字节码</h3><p>我们通过<code>Tools-&gt;Kotlin-&gt;Show Kotlin bytecode</code>打开<code>Kotlin</code>字节码界面，查看<code>Kotlin</code>文件的字节码形式。界面如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/4/166dd8283c09e742?w=644&amp;h=437&amp;f=png&amp;s=45209" alt></p>
        
          <p class="article-more-link">
            <a href="/2018/11/04/通过字节码看原理，带你去找kotlin中的static方法/#more">继续阅读全文 »</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://windinpub.com/2018/11/04/通过字节码看原理，带你去找kotlin中的static方法/" data-id="cjv6d9la90005ebi7a48rm8v2" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-子弹短信没有附近的人？教你子弹短信开启附近锤友" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/30/子弹短信没有附近的人？教你子弹短信开启附近锤友/" class="article-date">
  <time datetime="2018-08-30T09:58:02.000Z" itemprop="datePublished">2018-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/30/子弹短信没有附近的人？教你子弹短信开启附近锤友/">子弹短信没有附近的人？教你子弹短信开启附近锤友</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>转载请标明出处<a href="https://windinpub.com/2018/08/30/%E5%AD%90%E5%BC%B9%E7%9F%AD%E4%BF%A1%E6%B2%A1%E6%9C%89%E9%99%84%E8%BF%91%E7%9A%84%E4%BA%BA%EF%BC%9F%E6%95%99%E4%BD%A0%E5%AD%90%E5%BC%B9%E7%9F%AD%E4%BF%A1%E5%BC%80%E5%90%AF%E9%99%84%E8%BF%91%E9%94%A4%E5%8F%8B/">https://windinpub.com/2018/08/30/%E5%AD%90%E5%BC%B9%E7%9F%AD%E4%BF%A1%E6%B2%A1%E6%9C%89%E9%99%84%E8%BF%91%E7%9A%84%E4%BA%BA%EF%BC%9F%E6%95%99%E4%BD%A0%E5%AD%90%E5%BC%B9%E7%9F%AD%E4%BF%A1%E5%BC%80%E5%90%AF%E9%99%84%E8%BF%91%E9%94%A4%E5%8F%8B/</a></p>
<blockquote>
<p>子弹短信这款软件现在十分流行，新颖的界面友好的交互吸引了大量的新用户。但是，听说子弹短信还有“发现锤友”这一好玩的功能，但是很多小伙伴们没发现有这个功能，今天小编带你用另类的方法让附近锤友这个功能显示出来。</p>
</blockquote>
<h3 id="一、为什么没有发现锤友功能"><a href="#一、为什么没有发现锤友功能" class="headerlink" title="一、为什么没有发现锤友功能"></a>一、为什么没有发现锤友功能</h3><p> 目前发现锤友的功能只在锤子手机上才会显示，所以如果你是其它安卓手机或者苹果手机用户，那么你的子弹短信将不会显示出发现锤友的选项。没有发现锤友的功能似乎少了些许乐趣，接下来让我们来开户它。</p>
        
          <p class="article-more-link">
            <a href="/2018/08/30/子弹短信没有附近的人？教你子弹短信开启附近锤友/#more">继续阅读全文 »</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://windinpub.com/2018/08/30/子弹短信没有附近的人？教你子弹短信开启附近锤友/" data-id="cjv6d9lah0008ebi7pk4p4ajp" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-非侵入式无权限应用内悬浮窗的实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/12/非侵入式无权限应用内悬浮窗的实现/" class="article-date">
  <time datetime="2018-08-12T09:57:55.000Z" itemprop="datePublished">2018-08-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/12/非侵入式无权限应用内悬浮窗的实现/">非侵入式无权限应用内悬浮窗的实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>一般的悬浮窗实现方式，需要申请权限，并还是要对部分机型进行适配才能正常显示。那么这里，我们换一种思路，实现一个不一样的悬浮窗。</p>
</blockquote>
<h3 id="一、应用内悬浮窗实现思路"><a href="#一、应用内悬浮窗实现思路" class="headerlink" title="一、应用内悬浮窗实现思路"></a>一、应用内悬浮窗实现思路</h3><p>通常的悬浮窗是通过<code>WindowManager</code>直接添加的，在不同的Android系统上需要做不同的适配，在<code>Android</code>6.0以上的机型上，还需要引导用户跳转到设置界面手动开启悬浮窗权限。虽然这样实现悬浮窗有完整的解决方案，但是开启悬浮窗过程对用户并不是很友好。下面，我们换一种思路，去使用一个应用内悬浮窗，避免机型适配和权限申请的坑，让悬浮窗像普通的<code>View</code>一样显示在界面上。</p>
<p>一般悬浮窗的实现方案是向系统<code>window</code>添加<code>type</code>为<code>TYPE_PHONE</code>或者<code>TYPE_TOAST</code>的<code>View</code>，从而使悬浮窗可以作为一个独立的<code>View</code>进行展示。<code>Android</code>对这一行为作了限制，那我们可以考虑从比较常规的途径添加<code>View</code>：向每一个展示界面，即<code>Activity</code>，添加一个<code>View</code>作为悬浮窗。这样，我们使用悬浮窗时就可以避免适配和权限问题。那么，怎么样实现这样的悬浮窗更好呢？</p>
        
          <p class="article-more-link">
            <a href="/2018/08/12/非侵入式无权限应用内悬浮窗的实现/#more">继续阅读全文 »</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://windinpub.com/2018/08/12/非侵入式无权限应用内悬浮窗的实现/" data-id="cjv6d9lak0009ebi7p5d6a847" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-JockeyJS——WebView与JS交互解决方案，开源库使用和解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/15/JockeyJS——WebView与JS交互解决方案，开源库使用和解析/" class="article-date">
  <time datetime="2018-06-15T09:55:52.000Z" itemprop="datePublished">2018-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/15/JockeyJS——WebView与JS交互解决方案，开源库使用和解析/">JockeyJS——WebView与JS交互解决方案，开源库使用和解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>在Android上，对于JS交互，往往是通过系统原生提供的<code>@JavascriptInterface</code>这种方式进行交互的，而本人在项目的应该也是使用这种方式。最近听朋友提到一个库——JockeyJS，封装了JS交互逻辑，通过少量的接口让开发者只需要关注Java和JS之间的方法调用。我对它避开<code>@JavascriptInterface</code>的实现比较感兴趣，后来发现JockeyJS有于Java和JS之间的方法调用和回调有着不错的封装，于是便有了分析JockeyJS一文。</p>
</blockquote>
<h3 id="一、JockeyJS基本使用"><a href="#一、JockeyJS基本使用" class="headerlink" title="一、JockeyJS基本使用"></a>一、JockeyJS基本使用</h3><p>JockeyJS是几年前的库了，虽然是比较久的库，但放到现在仍然可用。</p>
<p>首先，需要在h5页面上引用项目中的<code>jockey.js</code></p>
<p>接下来在客户端进行配置，JockeyJS主要通过<code>on(String type, JockeyHandler ... handler)</code>和<code>send(String type, WebView toWebView, Object withPayload, JockeyCallback complete)</code><br>两个方法来实现Java与JS之间的交互。</p>
        
          <p class="article-more-link">
            <a href="/2018/06/15/JockeyJS——WebView与JS交互解决方案，开源库使用和解析/#more">继续阅读全文 »</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://windinpub.com/2018/06/15/JockeyJS——WebView与JS交互解决方案，开源库使用和解析/" data-id="cjv6d9laf0007ebi7rmjje7mp" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  

</section>
           
    <aside id="sidebar">
  
    
  <div class="widget-wrap">
     
        <h3 class="follow-title ">Follow me</h3>
     
    <div class="widget follow">
      
              <a class="github" aria-hidden="true" href="https://github.com/windinwork" target="_blank" title="Github"></a>
      
      
      
      
            <a class="email" aria-hidden="true" href="mailto:windinwork@gmail.com" target="_blank" title="邮箱"></a>
      
    </div>
  </div>


  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/05/02/Flutter状态管理学习手册[三]——Bloc/">Flutter状态管理学习手册[三]——Bloc</a>
          </li>
        
          <li>
            <a href="/2019/04/04/Flutter状态管理学习手册[二]——Redux/">Flutter状态管理学习手册[二]——Redux</a>
          </li>
        
          <li>
            <a href="/2019/04/02/Flutter状态管理学习手册[一]——ScopedModel/">Flutter状态管理学习手册[一]——ScopedModel</a>
          </li>
        
          <li>
            <a href="/2019/01/28/Android应用集成Office文件能力完全攻略/">Android应用集成Office文件能力完全攻略</a>
          </li>
        
          <li>
            <a href="/2018/12/02/使用Gradle编写蒲公英自动上传安装包和更新说明脚本/">使用Gradle编写蒲公英自动上传安装包和更新说明脚本</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title archive">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


  
    
<div class="widget-wrap">
    <h3 class="widget-title">Links</h3>
    <div class="widget">
        <ul>
            
            <li>
                <a href="https://windinpub.com">windin&#39;s blog</a>
            </li>
            
        </ul>
    </div>
</div>

  
    <!--微信公众号二维码-->


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2019 windin&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;windinwork@gmail.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png">
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->



 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>